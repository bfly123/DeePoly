import torch
import numpy as np
from typing import Dict
from src.abstract_class.base_net import BaseNet

class TimePDENet(BaseNet):
    """Neural network implementation for time-dependent problems"""
    
    def physics_loss(self, data_GPU: Dict, **kwargs) -> torch.Tensor:
        """Compute physics loss
        
        Args:
            data_GPU: GPU data dictionary containing training data
            **kwargs: Additional parameters
                - dt: Time step size, default 0
                - step: Time step type, default "pre"
            
        Returns:
            torch.Tensor: Loss value
        """
        # Get optional parameters
        dt = kwargs.get('dt', 0)
        step = kwargs.get('step', 'pre')
        
        # Get training data
        x_train = data_GPU["x_train"]
        x_bd = data_GPU["x_bd"]
        u_bd = data_GPU["u_bd"]
        param = data_GPU["param"]
        U_n = data_GPU["U_current"]

        # Get model predictions
        _, U = self(x_train)

        # Get parameters
        Re = param[0]["Re"]
        nu = param[0]["nu"]

# auto code begin
        # Extract physical quantities from output
        u = U[..., 0]

        # Calculate derivatives in each direction
        du_x = self.gradients(u, x_train)[0][..., 0]

        # Calculate 2nd-order derivatives
        du_xx = self.gradients(du_x, x_train)[0][..., 0]

        # L1 operators
        L1 = [-0.0001*du_xx]

        # L2 operators
        L2 = [u]

        # F operators
        F = [5-5*u**2]

        # N operators
        N = [
        ]

# auto code end

        # Using first-order forward Euler scheme: u^{n+1} = u^n + dt * [L1(u^{n+1}) + L2(u^n)*F(u^n)]
        # For neural network training, we directly minimize PDE residual
        # PDE residual: du/dt - L1(u) - L2(u)*F(u) = 0
        # Using first-order difference approximation: (u^{n+1} - u^n)/dt - L1(u^{n+1}) - L2(u^n)*F(u^n) = 0
        
        
        pde_loss = 0.0
        #dt = 0.01
        
        # Time evolution format: (u - u_n)/dt = L1[i] + L2[i]*F[i]
        for i in range(self.config.n_eqs):
            residual_i = (U[:,i] - U_n[:,i])/dt + L1[i] + L2[i]*F[i]
            pde_loss += torch.mean(residual_i**2)


        # Boundary conditions handling
        boundary_loss = self._compute_boundary_loss(data_GPU)
        boundary_loss_weight = 10.0
        
        # Total loss function
        total_loss = pde_loss + boundary_loss_weight * boundary_loss
        return total_loss
    
    def _compute_boundary_loss(self, data_GPU: Dict) -> torch.Tensor:
        """Compute boundary condition loss with modular design"""
        boundary_loss = 0.0
        global_boundary_dict = data_GPU.get("global_boundary_dict", None)
        
        if not global_boundary_dict:
            return boundary_loss
            
        for var_idx in global_boundary_dict:
            var_bc_dict = global_boundary_dict[var_idx]
            
            # Handle each boundary condition type
            if self._has_bc_data(var_bc_dict, "dirichlet"):
                boundary_loss += self._compute_dirichlet_loss(var_bc_dict["dirichlet"])
                
            if self._has_bc_data(var_bc_dict, "neumann"):
                boundary_loss += self._compute_neumann_loss(var_bc_dict["neumann"])
                
            if self._has_bc_data(var_bc_dict, "robin"):
                boundary_loss += self._compute_robin_loss(var_bc_dict["robin"])
                
            if self._has_periodic_data(var_bc_dict):
                boundary_loss += self._compute_periodic_loss(var_bc_dict["periodic"])
                
        return boundary_loss
    
    def _has_bc_data(self, var_bc_dict: Dict, bc_type: str) -> bool:
        """Check if boundary condition data exists and is non-empty"""
        return (bc_type in var_bc_dict and 
                var_bc_dict[bc_type]["x"].shape[0] > 0)
    
    def _has_periodic_data(self, var_bc_dict: Dict) -> bool:
        """Check if periodic boundary condition data exists"""
        return ('periodic' in var_bc_dict and 
                var_bc_dict['periodic']['pairs'])
    
    def _compute_dirichlet_loss(self, bc_data: Dict) -> torch.Tensor:
        """Compute Dirichlet boundary condition loss"""
        x_bc = bc_data["x"]
        u_bc = bc_data["values"]
        
        _, pred_bc = self(x_bc)
        return torch.mean((pred_bc - u_bc) ** 2)
    
    def _compute_neumann_loss(self, bc_data: Dict) -> torch.Tensor:
        """Compute Neumann boundary condition loss"""
        x_bc = bc_data["x"]
        u_bc = bc_data["values"]
        normals = bc_data["normals"]
        
        errors = []
        for i in range(x_bc.shape[0]):
            x_point = x_bc[i:i+1].clone().detach().requires_grad_(True)
            _, u_pred = self(x_point)
            
            grads = self.gradients(u_pred, x_point)[0]
            normal_derivative = torch.sum(grads * normals[i])
            
            errors.append((normal_derivative - u_bc[i]) ** 2)
        
        return torch.mean(torch.stack(errors)) if errors else 0.0
    
    def _compute_robin_loss(self, bc_data: Dict) -> torch.Tensor:
        """Compute Robin boundary condition loss"""
        x_bc = bc_data["x"]
        u_bc = bc_data["values"]
        normals = bc_data["normals"]
        params = bc_data["params"]
        alpha, beta = params[0], params[1]
        
        errors = []
        for i in range(x_bc.shape[0]):
            x_point = x_bc[i:i+1].clone().detach().requires_grad_(True)
            _, u_pred = self(x_point)
            
            if abs(beta) > 1e-10:
                grads = self.gradients(u_pred, x_point)[0]
                normal_derivative = torch.sum(grads * normals[i])
                robin_value = alpha * u_pred + beta * normal_derivative
            else:
                robin_value = alpha * u_pred
                
            errors.append((robin_value - u_bc[i]) ** 2)
        
        return torch.mean(torch.stack(errors)) if errors else 0.0
    
    def _compute_periodic_loss(self, periodic_data: Dict) -> torch.Tensor:
        """Compute periodic boundary condition loss"""
        total_loss = 0.0
        
        for pair in periodic_data['pairs']:
            x_bc_1, x_bc_2 = pair['x_1'], pair['x_2']
            constraint_type = pair['constraint_type']
            
            _, pred_bc_1 = self(x_bc_1)
            _, pred_bc_2 = self(x_bc_2)
            
            if constraint_type == 'dirichlet':
                total_loss += torch.mean((pred_bc_1 - pred_bc_2) ** 2)
            elif constraint_type == 'neumann':
                total_loss += self._compute_periodic_neumann_loss(pair, x_bc_1, x_bc_2)
                
        return total_loss
    
    def _compute_periodic_neumann_loss(self, pair: Dict, x_bc_1: torch.Tensor, x_bc_2: torch.Tensor) -> torch.Tensor:
        """Compute periodic Neumann boundary condition loss"""
        normals_1, normals_2 = pair['normals_1'], pair['normals_2']
        
        errors = []
        for i in range(x_bc_1.shape[0]):
            x_point_1 = x_bc_1[i:i+1].clone().detach().requires_grad_(True)
            x_point_2 = x_bc_2[i:i+1].clone().detach().requires_grad_(True)
            
            _, u_pred_1 = self(x_point_1)
            _, u_pred_2 = self(x_point_2)
            
            grads_1 = self.gradients(u_pred_1, x_point_1)[0]
            grads_2 = self.gradients(u_pred_2, x_point_2)[0]
            
            normal_deriv_1 = torch.sum(grads_1 * normals_1[i])
            normal_deriv_2 = torch.sum(grads_2 * normals_2[i])
            
            errors.append((normal_deriv_1 - normal_deriv_2) ** 2)
        
        return torch.mean(torch.stack(errors)) if errors else 0.0
    
    def prepare_gpu_data(self, data: Dict, U_current: np.ndarray = None) -> Dict:
        """Prepare GPU data for time PDE problems
        
        Args:
            data: Input data dictionary containing training data
            
        Returns:
            gpu_data: Dictionary containing GPU tensors
        """
        gpu_data = {}
        
        # Transfer coordinate data to GPU
        gpu_data["x_train"] = torch.tensor(
            data["x"], dtype=torch.float64, device=self.config.device, requires_grad=True
        )
        gpu_data["U_current"] = torch.tensor(
            U_current, dtype=torch.float64, device=self.config.device
        )
        
        # Transfer boundary data to GPU - Pure abstract U processing
        if "global_boundary_dict" in data:
            global_boundary_dict = {}
            for var_idx in data["global_boundary_dict"]:
                global_boundary_dict[var_idx] = {}
                for bc_type in data["global_boundary_dict"][var_idx]:
                    global_boundary_dict[var_idx][bc_type] = {}
                    
                    if bc_type == 'periodic':
                        # Handle periodic boundary condition pairs
                        global_boundary_dict[var_idx][bc_type]['pairs'] = []
                        for pair in data["global_boundary_dict"][var_idx][bc_type]['pairs']:
                            gpu_pair = {}
                            for pair_key, pair_value in pair.items():
                                if isinstance(pair_value, np.ndarray) and pair_value.size > 0:
                                    if 'x_' in pair_key:  # x_1, x_2
                                        gpu_pair[pair_key] = torch.tensor(
                                            pair_value, dtype=torch.float64, device=self.config.device, requires_grad=True
                                        )
                                    else:  # normals_1, normals_2, etc.
                                        gpu_pair[pair_key] = torch.tensor(
                                            pair_value, dtype=torch.float64, device=self.config.device
                                        )
                                else:
                                    gpu_pair[pair_key] = pair_value
                            global_boundary_dict[var_idx][bc_type]['pairs'].append(gpu_pair)
                    else:
                        # Handle regular boundary conditions
                        for key, value in data["global_boundary_dict"][var_idx][bc_type].items():
                            if isinstance(value, np.ndarray) and value.size > 0:
                                if key == "x":
                                    global_boundary_dict[var_idx][bc_type][key] = torch.tensor(
                                        value, dtype=torch.float64, device=self.config.device, requires_grad=True
                                    )
                                else:
                                    global_boundary_dict[var_idx][bc_type][key] = torch.tensor(
                                        value, dtype=torch.float64, device=self.config.device
                                    )
                            else:
                                global_boundary_dict[var_idx][bc_type][key] = value
            gpu_data["global_boundary_dict"] = global_boundary_dict
        else:
            gpu_data["global_boundary_dict"] = {}
        
        # Transfer boundary points and values for physics loss computation
        if "global_boundary_dict" in data and data["global_boundary_dict"]:
            # Extract boundary data for easier access in physics_loss - Pure abstract U processing
            x_bd_list = []
            u_bd_list = []
            for var_idx in data["global_boundary_dict"]:
                for bc_type in data["global_boundary_dict"][var_idx]:
                    if "x" in data["global_boundary_dict"][var_idx][bc_type]:
                        x_bd = data["global_boundary_dict"][var_idx][bc_type]["x"]
                        u_bd = data["global_boundary_dict"][var_idx][bc_type]["values"]
                        if isinstance(x_bd, np.ndarray) and x_bd.size > 0:
                            x_bd_list.append(x_bd)
                            u_bd_list.append(u_bd)
            
            if x_bd_list:
                gpu_data["x_bd"] = torch.tensor(
                    np.vstack(x_bd_list), dtype=torch.float64, device=self.config.device, requires_grad=True
                )
                gpu_data["u_bd"] = torch.tensor(
                    np.vstack(u_bd_list), dtype=torch.float64, device=self.config.device
                )
            else:
                # Create empty tensors if no boundary data
                gpu_data["x_bd"] = torch.zeros((0, self.config.n_dim), dtype=torch.float64, device=self.config.device)
                gpu_data["u_bd"] = torch.zeros((0, self.config.n_eqs), dtype=torch.float64, device=self.config.device)
        else:
            # Create empty tensors if no boundary data
            gpu_data["x_bd"] = torch.zeros((0, self.config.n_dim), dtype=torch.float64, device=self.config.device)
            gpu_data["u_bd"] = torch.zeros((0, self.config.n_eqs), dtype=torch.float64, device=self.config.device)
        
        # Add parameter data for physics loss
        gpu_data["param"] = [{"Re": 1.0, "nu": 1.0}]  # Default parameters for time PDE
        
        return gpu_data
    
    @staticmethod
    def model_init(config):
        """Initialize model
        
        Args:
            config: Configuration object
            
        Returns:
            TimePDENet: Initialized model
        """
        model = TimePDENet(
            in_dim=config.n_dim,
            hidden_dims=config.hidden_dims,
            out_dim=config.n_eqs
        ).to(config.device)
        return model 